\chapter{Arquitetura Básica do RouteFlow}

\section{Introdução ao Projeto Comunitário RouteFlow}

O projeto comunitário RouteFlow é uma proposta de oferta de serviços de
roteamento IP remoto de forma centralizada, e que visa um
desacoplamento efetivo entre o plano de encaminhamento e o
plano de controle (ROUTEFLOW, 2011). O objetivo é tornar as
redes IP mais flexíveis pela facilidade de adição,
remoção e especialização de protocolos e algoritmos.


O RouteFlow prove um serviço virtualizado de roteamento IP
em equipamentos com suporte ao protocolo \textit{OpenFlow}
seguindo o paradigma das redes definidas por software.
Basicamente, o RouteFlow interliga uma infraestrutura 
\textit{OpenFlow} com um ambiente virtual de roteamento 
IP baseado em ferramentas nativas do Linux (Quagga) para
um roteamento eficiente na estrutura física. Baseado em um
sistema de controle RouteFlow, os \textit{switches} 
são instruídos via controladores \textit{OpenFlow} que 
trabalham como proxies no intuito de traduzir as mensagens
e eventos entre o ambiente físico e virtual. 

O projeto conta com um número crescente de usuários no 
mundo (cerca de 1000 downloads e mais de 10000 visitantes
desde que o projeto começou em Abril de 2010). As principais
formas de contribuição para o projeto é através do sistema
de repositórios GitHub. Para citar alguns exemplos de contribuição
por parte da comunidade, é possível citar a contribuição
do Google nos plugins SNMP e o trabalho atual no suporte
ao MPLS e nas APIs de roteamento Quagga. A universidade
americana de Indiana contribuiu com uma interface gráfica
e com a execução de um piloto em seu \textit{testbed}.
% É possível adicionar mais exemplos de contribuições externas


O RouteFlow é composto basicamente por três módulos principais:
o cliente RouteFlow (RFClient), o servidor RouteFlow (RFServer) e
o proxy RouteFlow. A Figura \ref{fig:visaoGeralRouteFlow} mostra
de forma simplificada um cenário RouteFlow típico: engines de 
roteamento em um ambiente virtual geram uma base de 
informação de encaminhamento baseado nos protocolos 
de roteamento (OSPF, BGP) e processos ARP. Durante a 
execução do ambiente virtual, as tabelas de roteamento e 
tabelas ARP são coletadas pelos módulos RFClient executando
nas máquinas virtuais e traduzido em tuplas OpenFlow que
são enviadas para o RFServer, que faz a adaptação das 
informações para o ambiente físico e finalmente instrui o 
módulo RFProxy, uma aplicação controladora, para configurar
os \textit{switches OpenFlow} no ambiente físico.

Pacotes de encaminhamento dos protocolos de roteamento 
e controle de trágico (ARP, BGP, RIP e OSPF) são direcionados
pelo RFProxy para as interfaces virtuais correspondentes do
ambiente virtual. Entre o ambiente virtual e o ambiente existe
um switch virtual que também é controlado pelo RFProxy,
permitindo um caminho direto entre os ambientes, reduzindo 
o tempo das trocas de mensagens e sem a necessidade de passar
através do RFServer e do RFClient.

Abaixo temos os principais avanços da arquitetura do projeto
RouteFlow

\begin{itemize}
\item \textbf{Plataforma totalmente modular, extensível, 
configurável e flexível.} A arquitetura atual do RouteFlow 
foi feita pensando em sua própria evolução. Através do 
conceito de camadas, o RouteFlow conseguiu facilitar o entendimento
geral do código, facilitando o seu entendimento total por parte de 
seus usuários. A construção baseada em módulos independentes
torna o código mais claro, facilitando a portabilidade para outras 
linguagens ou o suporte à novas tecnologias. O exemplo mais 
claro sobre a independência dos módulos é o próprio módulo levado em consideração
na construção do trabalho de conclusão de curso em questão, o
RFProxy. 

O RFProxy faz a troca de mensagens com os outros módulos 
através de um sistema de banco de dados, sendo facilmente
portado para outras linguagens de programação e tecnologias.

Outro beneficio da construção baseada em módulos é a possibilidade
de execução do RouteFlow em múltiplos sistemas computacionais, 
fazendo-o executar como uma arquitetura distribuída. Tal 
característica será melhor explica nos itens abaixo.
\item \textbf{Suporte à replicação do estado da rede e grande
disponibilidade dos recursos.} Para melhorar a disponibilidade
do sistema, o RouteFlow foi construído de forma descentralizada, 
separando os dados relacionados ao estado das redes dos módulos de processamento.
Todos os dados relacionados ao estado das redes é armazenado
em um banco de dados centralizado, possibilitando que qualquer aplicação 
registrada tenha acesso. Dessa maneira é possível obter uma 
replicação dos processos, obtendo as vantagens e benefícios
de um sistema descentralizado. 

A versão atual do projeto ainda
não faz duplicação dos processos mas a ideia já é levada em
consideração para futuras implementações. 
\item \textbf{Armazenamento do histórico da rede e de estatísticas.}
Como citado no item anterior, a ideia de descentralização do RouteFlow
fez que os dados fossem armazenados em um banco de 
dados centralizado. Esse características traz consigo
uma série de vantagens, além de todas citadas anteriormente, ainda pode ser 
mencionado a possibilidade
de se manter um histórico das ações e decisões tomadas pelo
sistema. O RouteFlow, através do banco de dados centralizado, mantem 
um histórico de todo o sistema, bem como as estatísticas relacionadas 
à criação de regras e ao uso da rede. Tais características permitem
 aos pesquisadores
ou até mesmo aos administradores de redes ter um controle 
e um entendimento mais elaborado, podendo reproduzir o ambiente
em certos períodos de tempo. Sendo possível reproduzir o sistema
em ambientes em que o mesmo apresentou certa irregularidade ou
falha. 
As estatística ainda dão ao administrador um entendimento maior 
de como a rede é usada, possibilitando ao mesmo a tomada de
alguma decisão para a busca de melhorias.
\item \textbf{Possibilidade de ambientes com múltiplos controladores
\textit{OpenFlow}.} A arquitetura atual do RouteFlow foi
desenvolvida para ter suporte em cenários com múltiplos controladores
\textit{OpenFlow}. Tal característica permite aos pesquisadores
ou administradores particionar a rede e controlar cada região
com um controlador independente. Outro fator interessante é
que as camadas superiores do RouteFlow abstraem as diferenças
entre as versões 1.0/1.1/1.2/1.2 do OpenFlow, tornando fácil o
suporte à controladores heterogêneos. 
Para que tal característica fosse suportada, o código do RouteFlow
passou por um processo de padronização, melhorando ainda 
mais a legibilidade do projeto.
\end{itemize}

% Melhorar o titulo
\section{Banco de Dados Centralizado com Suporte a IPC}

Nesse capitulo será explicado com detalhes a arquitetura de 
banco de dados centralizado e seu suporte aos mecanismos
de comunicação entre processos usados pelo projeto RouteFlow.
Também serão abordados as principais vantagens e desvantagens
da arquitetura.

Várias abordagens foram proposta pelo RouteFlow para um
esquema unificado de comunicação entre processos (IPC). 
Inúmeras delas foram testadas e avaliadas até se conseguir 
traçar as principais vantagens e desvantagens de cada uma delas.
Soluções baseadas em filas de mensagens, como o RabbitMQ
ou o ZeroMQ foram descartadas por causa da grande complexidade
de implementação e manutenção. Soluções baseadas em serialização
de mensagens, como ProtoBuffers e Thrift, se apresentaram como
boas soluções mas requiriam uma lógica adicional para o armazenamento
pendente e para mensagens já consumidas. Durante o estudo
de banco de dados Não SQL para armazenamento persistente,
surgiu as primeiras ideias do uso de um banco de dados como
ponto central de um mecanismo de troca de mensagens entre 
processos (IPC) e consequentemente manter o histórico das 
ações tomadas pelo RouteFlow para permitir a replicação de certas
situações.

Depois de levar em consideração as mais populares opções de 
banco de dados Não SQL (MongoDB, Redis, CouchDB), foi 
decidido sobre a implementação de um banco de dados centralizado
e dos mecanismos de troca de mensagens entre processos (IPC) 
utilizando-se o MongoDB. Os principais fatores para a escolha foram
a facilidade de programação, suporte nativo a inúmeras linguagens de 
programação, suporte nativo à tecnologia JSON e a existência de 
mecanismo para replicação e distribuição. A ideia por trás do
mecanismo de troca de mensagens (IPC) é completamente
independente da escolha do banco de dados e por isso não 
foi levada em consideração.

No núcleo do RouteFlow estão os mapeamentos entre o ambiente
físico controlado e o ambiente virtual executando as tarefas de
roteamento. A confiabilidade desses estados de rede é imprescindível 
para o RFServer e se torna difícil de manter sem a ajuda de 
algum módulo externo. Um banco de dados externo se encarrega
desse objetivo, tendo sua configuração mais flexível. Estatísticas
coletadas pelo RFProxy também podem ser armazenadas em 
um banco de dados centralizado, baseado em serviços adicionais
é até possível implementar ferramentas para análise dos dados 
ou até mesmo visualização.







O RouteFlow armazena a lógica de
controle dos \textit{switches OpenFlow} na infraestrutura de rede,
através de uma rede virtual composta por máquinas virtuais, cada uma executando um código
(engine) de roteamento de domínio público (open source).
Essas máquinas virtuais podem ser interconectadas
de maneira a formar uma topologia lógica, espelhando a
topologia de uma rede física correspondente ou uma topologia
virtual simplificada. O ambiente virtual é armazenado em um
servidor externo, ou um conjunto deles, que se comunicam com
os equipamentos do plano de dados através de um controlador
\textit{OpenFlow}, que transporta para o plano de encaminhamento as
decisões tomadas pelos protocolos de roteamento no plano de
controle (OSPF, BGP, RIP). 

\begin{figure}[h]
\centering
\includegraphics[width=160mm]{visaoGeralRouteFlow.png}
\caption{Visão geral do RouteFlow.}
\label{fig:visaoGeralRouteFlow} 
\end{figure}

A Figura \ref{fig:visaoGeralRouteFlow} ilustra uma sub-rede com
switches programáveis, em que a lógica de roteamento é
implementada no servidor RouteFlow. O resultado consiste
numa solução flexível de alto desempenho e comercialmente
competitiva, a partir da combinação de recursos disponíveis,
como, por exemplo:

\begin{enumerate}[{a)}] 
\item switches programáveis de baixo
custo e software embarcado reduzido (\textit{OpenFlow}); 
\item pilhas de protocolos de roteamento open source (QUAGGA, 2009; XORP,
2011); e 
\item servidor de prateleira de alto poder de
processamento e, também, de baixo custo. 
\end{enumerate}

Cabe ressaltar que, apesar de o controle estar fisicamente
centralizado, ele continua distribuído logicamente. Dessa
forma, não é necessária qualquer alteração dos protocolos de
roteamento existentes. Além disso, a solução pode tornar-se
mais escalável no futuro, com o uso
de vários servidores de alto desempenho.

\section{Descrições dos Principais Componentes do RouteFlow}
O RouteFlow é dividido basicamente em três aplicações
básicas: RFClient, RFServer e RFProxy. Na Figura
\ref{fig:componentesRouteFlow} temos uma visão geral das
aplicações:

\begin{itemize} 
\item RFClient executa como um programa
executável em um máquina virtual, detectando
mudanças na tabela ARP do Linux e na tabela de roteamento.
As informações de roteamento são enviadas para o
RFServer quando são atualizadas.
\item RFServer é uma aplicação independente que gerencia as
máquinas virtuais que estão executando o RFClient. 

O RFServer mantem o mapeamento entre as instâncias das
máquinas virtuais executando o RFClient e as interfaces
correspondentes aos switches e suas respectivas portas. É
conectado ao RFProxy para instruí-lo como configurar os
fluxos e também como configurar o Open vSwitch que mantém a
conectividade de todo o ambiente composto pelas máquinas virtuais.
\item RFProxy é uma aplicação responsável pelas interações
entre os switches \textit{OpenFlow} (identificados pelos seus
datapaths) via o protocolo \textit{OpenFlow}. Ele aguarda instruções
do RFServer e o notifica à respeito de eventos na rede.
Atualmente é executado como um módulo vinculado aos
controladores \textit{OpenFlow}. 

O RouteFlow tem suporte aos
controladores NOX e POX, sendo que a proposta do trabalho é
adicionar suporte ao Floodlight. 
\end{itemize}

\begin{figure}[h] 
\centering
\includegraphics[width=150mm]{componentesRouteFlow.png}
\caption{Componentes principais do RouteFlow.}
\label{fig:componentesRouteFlow} 
\end{figure}

\section{Protocolo RouteFlow}

É o protocolo desenvolvido e usado para a comunicação entre
os componentes do RouteFlow. Nele, estão definidas as
mensagens e os comandos básicos para conexão e configuração
das máquinas virtuais e, também, gerenciamento das entradas
de roteamento em hardware. Entre os campos da
mensagem-padrão estão: identificação do controlador,
identificação da máquina virtual, tipo da mensagem,
comprimento e dados. 

O proxy RouteFlow recebe os comandos do
servidor RouteFlow através deste protocolo e de acordo com o
tipo de comando executa as principais ações, muitas delas
exigindo a comunicação com os switches físicos. A
comunicação com os switches físicos é feita via protocolo
\textit{OpenFlow}, fazendo o proxy RouteFlow agir como
uma espécie de "tradutor" entre os dois protocolos.
